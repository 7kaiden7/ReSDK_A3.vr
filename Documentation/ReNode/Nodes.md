
# Узлы

<img src="Data/node_sample.png" width="200px">

1. Узел.
2. Входные порты. 
3. Выходные порты

Основные правила узлов:
- Все выполнения начинаются с точек входа. Точками входа *обычно* являются красные или желтые узлы без входных портов.
- **Выходные** порты одного узла могут быть подключены к **входным** узлам другого. Нельзя объеденить 2 входных или выходных порта разных узлов. Иными словами, **правые** (выходные) порты узла "А" могут быть подключены к **левым** (входным) портам узла "Б".
- Узел не может быть подключен сам к себе.
- Создание циклических связей невозможно. Все графы в ReNode ацикличные.

## Узел

Большинство узлов разделяются по цвету для упрощения понимания природы и тонкостей работы конкретных узлов. Примеры различных типов узлов ниже:

<img src="Data/nodes_alltypes.png" width="800px">

### Объектные (1-6)

Все объектные узлы вызывают функции или манипулируют свойствами благодаря входному порту "Цель" синего цвета, который есть у каждого объектного узла (кроме точек входа). Если опция рядом с портом "Цель" отмечена красным цветом, значит в графе не может быть использован этот узел без явного подключения к порту "Цель".

Точки входа:

1. Событие. Начальный пункт выполнения узла. Большинство событий нельзя вызвать вручную, так как они вызываются самим SDK.
2. Определение/переопределение точки входа. Предназначен для переопределения логики точки входа в дочерних графах, унаследованных от базового

Выполняемые:

3. Метод (функция класса/графа). Если функция класса создана пользователем, то она должна так же иметь определение (2).
4. Функция-геттер. Некоторая функция, которая не меняет функционал объекта и служит для получения каких-то значений.

Хранящие данные:

5. Свойство графа. Цвет и иконка отражают тип данных свойства. Есть 2 узла для каждого свойства: получить значение и установить его.
6. Константа. Неизменяемое значение объекта. Обычно константами в графах определяют то, что не может быть изменено на протяжении жизни объекта.

### Системные (7)
Сюда входят большинство системных узлов серого цвета, управляющих контролем выполнения графа.

### Функциональные (8-10)

8. Функции. Различные функции общего назначения, способные выполнять набор действий внутри себя. Их отличием от методов (3) является то, что у них нет порта цель, отвечающего за то, кем вызывается указанный узел.
9. Операционные. Простые узлы, которые выполняют ровно по одной операции за раз (сложить числа, преобразовать значение)
10. см. 9.

### Специализированные (11-13)
11. Свитчеры (переключатели). Предназначены для выбора значений из перечислений.
12. Структурные. Управляют значениями структур (получение, установка).
13. см. 12

## Входные порты

Входные порты, это порты, которые получают значения на вход из подключенных связей. В некоторых узлах к входным портам прилагаются пользовательские опции, представленные в виде виджетов ввода различных данных (числа, строки, чекбоксы, листбоксы). Если в порт с пользовательской опцией не подключена связь, то будет использовано значение из этой пользовательской опции.

## Выходные порты

Выходные порты, это порты, которые отдают на выход значения, обработанные узлом. Пример ниже отдает результат, равный количеству клиентов, занявших указанную роль. Так же он посылает импульс на порт "Выход" передавая управление следующему узлу, подключенному к нему.

<img src="Data/node_sample.png" width="300px">

## Типы портов
Каждый порт любого узла имеет свой тип портов. Для упрощенной ассоциации подключения обращайте внимание на форму и цвет портов. Чаще всего вы можете подключить 2 порта разных узлов если они имеют одинаковый цвет. Для просмотра типов портов наведите мышь на выбранный узел.

<img src="Data/nodes_port_types.png" width="500px">

Полный список типов с обозначением цветов можно посмотреть в [предыдущем руководстве](Datatypes.md#основные-типы).

### Порты выполнения

Порты выполнения - это специальные порты, отвечающие за организацию порядка выполнения узлов.

> !!! Внимание: Подробнее про преобразования [тут](#преобразования-типов)

<img src="Data/nodes_port_exec.png" width="500px">

На изображении выше импульс выполнения поступает на самый левый узел "Сообщение на экране". После выполнения этого узла импульс поступит на следующий узел, подключенный к первому и так далее. В итоге при выполнении этих 3х узлов у нас появится 3 сообщения на экране в следующем порядке: 
- "Сообщение 1"
- "Следующее сообщение"
- "Последнее сообщение"

Для полного примера работы представлено изображение ниже:

<img src="Data/nodes_port_execsample.png" width="500px">

Передача импульса выполнения происходит по зеленым стрелкам:
1. Вызывается узел "При назначении". Этот узел вызывается когда клиент зашёл за определенную роль.
2. Получаем полное имя персонажа в именительном падеже. Пример: "Хоба Савин"
3. Выводим локальное приветственное сообщение мобу в чат "Привет Хоба Савин"
4. Преобразование типа. Подробнее [ниже](#преобразования-типов-объектов)
5. Устанавливаем голод.

### Порты данных

Порты данных это круглые порты различных цветов. Они отвечают за передачу данных между узлами.

<img src="Data/nodes_port_valexample.png" width="800px">

На примере выше выполняются операции сложения и вывод сообщений на экран. Ярко-зелеными стрелочками отображается передача значений между узлами а цифры рядом с ними - какие значения передаются. В результате выполнения на экране выведется 2 сообщения:
1. "3"
2. "5"

### Автоматические порты

Автоматические порты, это порты белого цвета, к которым можно подключать различные порты других типов. При создании связи с автопортом определяется и устанавливает его цвет (тип). 
На автоматические порты действуют ограничения на подключения, которые можно посмотреть если навести мышь на узел внутри графа.

<img src="Data/nodes_auto_desc.png" width="500px">

На изображении выше показано описания узла сложения двух чисел. Из описания становится ясно, что автоматические порты этого узла принимают значения дробных или целых чисел. Соответственно, например массивы строк или объекты не могут быть подключены в этот автоматический порт.

#### Использование автоматических портов

Для примера попробуем определить наличие элемента в массиве. Добавим в граф узел "Содержит элемент".

<img src="Data/nodes_autoarr_desc.png" width="500px">

Мы видим, что на вход данный узел допускает массив в порт "Массив" и значение в порт "Элемент".
Создадим некоторую буквальную строку со значением "Первый;Второй;Третий" и разделим её на массив строк разделителем ";". 

После этого подключим полученный массив строк (`["Первый","Второй","Третий"]`) в наш узел "Содержит элемент". При подключении мы увидим, что все белые порты установят новый цвет, а при описании узла "Содержит элемент", выходной порт "Элемент" будет являться портом типа строки.
Подключим в порт элемента новую буквальную строку, наличие которой будет проверяться в массиве:

<img src="Data/nodes_autoarr_act.png" width="500px">

В примере выше мы проверяем наличие элемента в массиве. Если элемент существует - выходной порт узла "Содержит элемент" станет равен значению **Истина**. В иных случая он будет равен значению **Ложь**.

### Преобразования типов

Иногда может возникнуть ситуация, когда нам нужно преобразовать один тип данных в другой. Например, дробное число в целое, число в строку, булево в число и т.д. 

В разделе выше про [порты данных](#порты-данных) вы могли заметить узел преобразования целого числа в строку. Библиотека узлов предоставляет специальные узлы для преобразования различных типов данных.

## Библиотека узлов

Библиотека узлов, это банк-хранилище системных и пользовательских узлов, которые можно добавлять в ваш граф. Для добавления откройте библиотеку узлов, нажав **Tab**. Поле ввода предоставляет возможность поиска узла по имени.

Основные разделы в библиотеке, на которые стоит обратить внимание:
- **Игровая логика**: категории и узлы для работы с режимами, ролями, системой задач.
- **Игровые объекты**: утилиты и специфичные узлы для взаимодействия с игровым миром - его модификацией, сбором информации, созданием и уничтожением.
- **Клиенты**: узлы работы с объектами клиентов, подключающихся к серверу во время игры.
- **Массивы**: утилиты для манипуляции массивами - создание, добавление, информация.
- **Математика**: узлы для работы с числами и логическими данными (и, или)
- **Объекты**: базовые узлы манипуляции с объектом и типами объектов.
- **Операторы**: узлы, управляющие контролем выполнения графа.
- **Перечисления**: утилиты для работы с типами перечислений (например, слоты инвентаря - перечисление)
- **Преобразования**: узлы для конвертации различных типов данных.
- **Система**: специфичные для платформы узлы (например, количество кадров, время работы платформы)
- **Системные**: декоративные узлы, такие как: группа, заметка
- **Строки**: узлы для работы с типом данных "строка".
- **Структуры**: утилиты для работы с типами структур


## Различия узлов

Узлы условно можно разделить на 2 основных категории: чистые и функциональные.

<img src="Data/nodes_pureimpure_sample.png" width="500px">

### Чистые узлы
Чистыми являются узлы, выполняющие простые операции, получающие значения объектов без сложных расчетов, либо вычисляющих какие-то значения на основе входных данных без их изменения.
В контексте объектной системы чистые узлы это константы, узлы получения значений свойств, а так же пользователськие функции, которым задан признак "Чистая функция".

> !!! Помните: Узел считается "чистым" если не имеет ни одного порта выполнения. 

### Функциональные узлы
Функциональными являются узлы, которые **могут** изменять входные данные. Примером функционального узла может быть узел установки типов ключа. 

<img src="Data/nodes_pureimpure_sample2.png" width="500px">

Он предназначен для установки совместимости ключа с дверями, которые можно открыть. При выполнении этого узла в объекте ключа, подключенном к порту "Цель" будет изменено значение с информацией о типах замков, которые можно открыть ключом.


# Основные операторы

Основные операторы находятся в библиотеке узлов раздела "Операторы". Они отвечают за контроль выполнения графом.
....................................... дополнить...

## Контроль выполнения

Ниже представлены различные встроенные узлы общего назначения, позволяющие контролировать выполнение графа. 

<img src="Data/nodes_control_base.png" width="500px">

### Ветка
.......непонятно
Оценивает условие ветки. После выполнения узел просматривает входное значение логического значения порта "Условие" и выводит импульс выполнения на соответствующий выходной порт. Если на вход в порт "Условие" передан результат, равный истине - выполнение будет передано на узел, подключенный к порту "Истина". В ином случае будет передано управление на порт "Ложь".

### Переключатель
.....рефакторить описание и пример для переключателя
Узел принимает входные данные выполнения и переключается между двумя выходными данными выполнения. При первом вызове выполняется выход "A". Во второй раз "Б". Потом "А", потом "Б" и так далее. Узел также имеет логический выход, позволяющий отслеживать, когда поступил импульс на выходной порт "A".

### Последовательность

Этот узел позволяет одному импульсу выполнения запускать последовательность событий по порядку. Узел может иметь любое количество выходов, все из которых вызываются, как только узел последовательности получает входной импульс выполнения. Они всегда вызываются по порядку, без каких-либо задержек.

### Вернуть значение

Возвращает значение из функции события или любой другой точки входа. При поступлении импульса на этот порт, выполнение функции прерывается а управление передается вызывающему узлу. 

На примере ниже представлен пример использования возвращаемого значения. 

<img src="Data/nodes_control_sample.png" width="700px">

- Выполнение начинается с точки входа "Стартовая функция" (1). Эта точка входа выполняет другую функцию с названием "Вызываемая тестовая функция" (2). 
- Внутри этой функции объединяется строка, полученная из порта "Входная строка" и выполнение передается с 3 на 4. 
- Полученный результат возвращается **вызывающей функции (2)** со строкой "Привет ReNode" и эта строка выводится в окне на экране.

..... как складываются строки????
..... игровой пример нужен: пример быстрой функции создания инвентаря

### Вызов базового метода

Вызов базового метода. Этот узел вызывает такую же функцию (точку входа) родительского класса. Например, в некотором классе "А" есть функция "Действие". При создании собственного класса "Б", унаследованного от "А" и переопределяющего логику функции "Действие" мы можем выполнить "Действие" от родительского класса "А" с помощью этого узла "Вызов базового метода".

На примере ниже создано 2 графа. Первый - "Adventurer...", с созданной функцией класса "Некоторая функция". Второй - "LateAdventurer...", унаследованный от первого. 

<img src="Data/nodes_super_sample.png" width="700px">

При вызове нашей функции внутри графа "Adventurer..." на экране выведется сообщение "Первый раз". При вызове нашей функции из "LateAdventurer..." на экране сначала выведется сообщение "Первый раз" а затем выведется сообщение "Второй раз". Следуя концепции наследования вызов базовых методов графов позволяет избавится от копирования кода. 

Так например, мы можем сделать роль горожанина, в которой при получении снаряжения будет выдан паспорт. После этого мы можем создать роль городского стражника, унаследованного от графа горожанина. При выдаче экипировки стражнику (например меча) сделаем вызов базового метода и таким образом мы выдадим паспорт нашему странжику вместе с мечом.

## Итераторы

Итераторы служат для повторения различных действий. Каждый тип итератора имеет свою логику условия и выполнения. Например, с помощью итераторов можно создать несколько свечей в ящике, или вывести всем мобам в игре сообщение в чате.

<img src="Data/nodes_iter_base.png" width="700px">

### Цикл
Выполнение действий несколько раз пока условие истинно. При поступлении входного имульса выполняется проверка условия. Если оно истнно - выполняется тело цикла. После завершения выполнения узлов, подключенных к порту "Тело цикла" проверка условия выполняется снова. Если она опять истинна - тело цикла выполняется снова и так до тех пор, пока условие будет истиной. Как только условие станет ложью - выполнение будет передано на порт "При завершении".

<span style='color:red'>Примечание: </span>Обратите внимание, что узел цикла может выполнить тело цикла только 10000 раз. При достижении лимита выполнения цикл остановится. Данное ограничение является особенностью платформы.

### Цикл в диапазоне

Вызывается несколько раз в зависимости от указанного диапазона значений. Диапазон задается входными числовыми параметрами "Первый индекс" и "Последний индекс", причем диапазон задается от меньшего к большему.

Например, первый индекс равен `1`, последний равен `5`. Другой пример: первый индекс равен `-100`, последний равен `100`. Если первый индекс будет больше последнего, то тело цикла не выполнится. (прим. от `50` до `20` - ошибка)

Цикл выполняется пока выходной порт индекс входит в указанный диапазон. Пример:

1. Поступает импульс на узел "Цикл в диапазоне"
2. В нём задан диапазон от 5 до 7. (первый индекс = 5, последний = 7)
3. Поступает импульс на выходной порт "Тело цикла". В этот раз индекс будет равен 5. При завершении выполнения тела цикла выполнение будет перенаправлено к вызываемому узлу "Цикл в диапазоне".
4. Повторяются действия из пункта 3, но индекс равен 6. Тело цикла выполняется снова.
5. На следующей итерации тело цикла снова выполняется, но индекс в этот раз уже равен 7.
6. После действия в пункте 5 индекс станет равен 8, что не входит в диапазон от 5 до 7. В этом случае импульс выполнения будет передан на порт "При завершении".

<img src="Data/nodes_iter_forsample.png" width="600px">

В примере выше появится несколько сообщений на экране в следующем порядке:
- "Индекс = 3"
- "Индекс = 4"
- "Индекс = 4"
- "Выполнение завершено"


### Цикл по списку

Цикл для перебора коллекций (например, массивов). Выполняется столько раз, сколько элементов в списке/коллекции. При поступлении входного импульса выполняется перебор каждого элемента, подавая сигнал на выходной порт "Тело цикла". После обхода всех элементов цикла импульс выполнения передается на порт "При завершении". Если на вход поступает пустая коллекция (например, пустой массив) то тело цикла не будет выполнено.

При выполнении тела цикла элемент становится значением коллекции на текущей итерации, а индекс становится индексом этого элемента. **Индексация коллекций начинается с 0**.

Обратите внимание, что выходные порты "Элемент" и "Индекс" могут быть использованы только в ветке, идущей от порта "Тело цикла". При попытке использовать их *снаружи цикла* (в ветке "При завершении") вы получите ошибку на этапе компиляции графа.

Ниже представлено изображение с примером использования цикла по списку.

<img src="Data/nodes_iter_foreachsample.png" width="650px">

В примере выше появится несколько сообщений на экране в следующем порядке:
- "Приветствуем участника Вася под номером 0"
- "Приветствуем участника Петя под номером 1"
- "Приветствуем участника Коля под номером 2"
- "Выполнено"

### Контроль цикла

Иногда могут быть необходимы принудительные остановки, или пропуски итераций циклов. Для этого существуют узлы "Пропустить итерацию" и ""Прервать цикл". Они могут быть использованы внутри тела цикла для узлов: **Цикл**, **Цикл в диапазоне**, **Цикл по списку**.

- **Пропустить итерацию** - Пропускает текущую итерацию цикла. При поступлении импульса на этот порт, цикл продолжается с следующей итерацией, если таковая возможна.
- **Прервать цикл** - Останавливает выполнение цикла. При поступлении импульса на этот порт, цикл прерывается.

<img src="Data/nodes_iter_forskipsample.png" width="900px">

В примере выше итерируется диапазон от 5 до 15. В результате выполнения на экране появится несколько сообщений в следующем порядке:
- "Я знаю цифру 5"
- "Я знаю цифру 6"
- "Эээ..."
- "Эээ..."
- "Я знаю цифру 9"
- "А больше я ничего не знаю"

## Преобразования типов объектов

Представим ситуацию: нам нужно сделать, чтобы при смерти персонажа на определенной роли все ключи вокруг него смогли открывать дверь с именем "secret_door". Для этого обратимся к событию "При смерти за роль" и создадим немного узлов:

<img src="Data/nodes_castto_sample1.png" width="800px">

На изображении выше при смерти персонажа мы получаем ближайшие игровые предметы рядом с его телом. Если этих элементов больше нуля то мы выбираем первый игровой предмет из массива и собираемся ему задать тип ключа "secret_door". 

Но узел "Ближайшие предметы" возвращает массив предметов. А для выполнения узла "Задать типы ключа" нам нужен объект типа "Key". Мы точно знаем что в момент смерти персонажа рядом с ним не было абсолютно никаких предметов кроме ключей. Как же исправить ситуацию?

Для этого существует узел "Преобразовать тип". На вход мы передаем объект и в опции указываем к какому типу будет совершено преобразование. По факту преобразование не несет никакого функционального изменения объекта и нужно для двух вещей:
- Подсказать редактору тип объекта, так как он не умеет полностью вычислять фактические типы портов при выполнении.
- Обезопасить себя от ошибок во время выполнения симуляции или ещё хуже - во время работы сервера.

Добавляем узел преобразования типа и указываем значение опции преобразования - Ключ.

<img src="Data/nodes_castto_sample2.png" width="800px">

> !!! Примечание: Мы не можем преобразовывать типы объектов от **базового к дочерним** без использования "Преобразования типов". Однако преобразовать **дочерний тип в базовый** мы можем.  

## Асинхронность
ReNode позволяет создавать задержки выполнения между подключенными узлами. Для этого используются следующие узлы:

### Таймер

<img src="Data/node_timer.png" width="350px">

Узел "Таймер" предназначен для исполнения задержек (пауз) между действиями внутри функции. При поступлении входного импульса выполнение приостанавливается на время в секундах, указанное во входном порту "Пауза" и после этого пошлёт импульс на выходной порт "Вызов". Данный узел имеет некоторые накладные расходы при выполнении, поэтому не гарантируется задежрка с указанной точностью времени до миллисекунды. 

Обратите внимание, что таймеры не могут быть использованы в точках входа, которые должны возвращать значения.

### Условный таймер

<img src="Data/node_timercond.png" width="350px">

Узел "Условный таймер" предназначен для исполнения задержек (пауз) между действиями внутри функции. При поступлении входного импульса выполнение приостанавливается до тех пор, пока условие, вычисляемое каждый кадр не будет истинно. Как только условие станет истинно таймер будет остановлен и пошлётся импульс на выходной порт "Вызов".

# Локальные функции и события
Вы можете создавать локальные функции, функции-действия и события внутри своих графов, которые можно вызывать из любых мест. Для настройки созданной локальной функции нажмите **ПКМ** по ней.

<img src="Data/nodes_functions_base.png" width="500px">

## Создать функцию
Локальная функция это набор выполняемых действий. Функция может иметь сколько угодно портов и возвращаемое значение при необходимости. 
Внутри локальных функций не передаются объект графа и локальные переменные. Все необходимые данные, которые будут использованы внутри функции должны быть явно переданы через созданные порты совместимого типа.

<img src="Data/nodes_functions_anon_rmb.png" width="500px">

- Добавить порт - добавить порт типа *значение* в функцию.
- Добавить порт (массив) - добавить порт типа *массив* в функцию.
- Добавить порт (сет) - добавить порт типа *сет* в функцию.
- Удалить порт - удалить созданный порт.
- Возвращаемое значение - установить возвращаемое значение для функции. Если оно не требуется - выберите пункт "Без возврата".

## Функция-действие

Функция-действие это набор выполняемых действий по отношению к объекту. Такие функции предназначены для выполнения инструкций с возможностью возврата результата. В функции-действие всегда есть порт "Цель", который является объектом, вызвавшим действие. По аналогии с обычной функцией действиям внутри недоступны локальные переменные, созданные в графе, но они могут иметь сколько угодно дополнительных портов и опциональное возвращаемое значение. При нажатии на **ПКМ** доступны следующие опции:
- Добавить порт - добавить порт типа *значение* в функцию.
- Добавить порт (массив) - добавить порт типа *массив* в функцию.
- Добавить порт (сет) - добавить порт типа *сет* в функцию.
- Удалить порт - удалить созданный порт.
- Возвращаемое значение - установить возвращаемое значение для функции. Если оно не требуется - выберите пункт "Без возврата".
- Установить тип объекта - устанавливает тип обязательного порта "Цель".

В примере ниже попробуем разобраться с созданием функций-действий. В системе задач мы можем переопределить некоторые действия задачи, как например: действие при провале задачи, при успешном выполнении и обработать описание. 
Описание задачи выводится в окне воспоминаний персонажа. Попробуем создать кастомное описание для задачи. Для начала создадим обработчик описания и наведем на него мышь для просмотра необходимого набора входных и выходных параметров функции-действия.

<img src="Data/nodes_functions_event_desc.png" width="500px">

На изображении выше мы видим параметры задачи: Первый параметр это Цель. Он должен быть типа "Задача" или любой из дочерних типов от задачи. 

Создаем новую функцию-действие и через **ПКМ** зададим тип объекта через пункт *"Установить тип объекта"*, выбрав "Задача".

Далее в информационном окне узла мы видим требуемое возвращаемое значение "Описание" типа строка. Зададим его через **ПКМ** - *"Возвращаемое значение"*.

Наша функция-действие готова. Теперь мы сможем подключить её к обработчику описания задачи в порт значение и определить логику получения описания.

<img src="Data/nodes_functions_event_sample.png" width="900px">

В примере выше мы создаем собственную логику получения описания задачи, которое будет возвращать строку типа "Выполнить задачу Задача. Задача выдана 1 людям.".

# Событие

События это набор действий по отношению к объекту. Такие функции предназначены для реакции на определенные действия.

Отличия от функции-действия заключаются в том, что события не могут возвращать значений, но могут быть сгруппированы, т.е. один обработчик может иметь более одного события. Обработчики для функций-действий же могут иметь только одно действие.

!!! ВНИМАНИЕ В текущей версии ReNode события не реализованы в полной мере.


## [Вернуться назад](README.md)