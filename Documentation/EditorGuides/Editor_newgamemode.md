# Создание режима

Ознакомившись с основами редактора перейдем к созданию режима. Любому режиму для работы требуется карта и объекты на ней (например точки спавна).
Перейдите в раздел меню `Карта` и нажмите `Создать новую карту`

![Создание новой карты](Data/editor_createmap.png)

Обратите внимание, что после создания новой карты она изначально будет загружена в рабочую область, поэтому предварительно сохраните и скомпилируйте текущую карту если это необходимо.

<img src="Data/editor_createmap_apply.png" width="60%">

При создании появится окно загрузки после чего редактор будет перезапущен с новой картой.

<img src="Data/editor_createmap_load.png" width="80%">

После загрузки вам будет предложено ввести имя вашей новой карты.

<img src="Data/editor_createmap_setname.png" width="100%">

Вводим название нашей карты. В серии руководств по созданию режимов и ролей мы будем использовать карту SampleMap. Нажимаем зеленую кнопку `Создать` и появляемся в привычном окне редактора.

Для начала построим небольшую сцену из земли. Обратите внимание, что верхние блоки мы поместили в слой `Потолок`, чтобы скрыть его на момент редактирования. Попробуйте самостоятельно поместить блоки потолка в отдельный слой. Подробнее о том как это сделать вы можете повторно посмотреть в [разделе о слоях](Editor_basics.md#список-объектов-и-слои)

<img src="Data/editor_createmap_basescene.png" width="100%">

<img src="Data/editor_createmap_basescene_hideup.png" width="100%">

Наша замечательная карта, по которой можно передвигаться завершена! Давайте наконец создадим для неё игровой режим!

Переходим в раздел меню `Инструменты` и выбираем `Создать режим`.

<img src="Data/editor_creategamemode.png" width="60%">

В открывшемся окне вводим название нашего режима. Префикс `GM` можно не писать, он добавится автоматически если вы его не указали.

<img src="Data/editor_creategamemode_setname.png" width="60%">

Нажимаем `Ок`. Сгенерируются файлы режима и базовой роли для него. После этого новый режим с ролью добавится в библиотеку классов и наш режим будет создан с именем `GMSampleGamemode`.

Наш режим создан в папке `Src\host\GameModes` в виде папки с аналогичным именем, которое мы указали в предыдущем окне. Внутри этой папки изначально лежат 3 файла:
- **GMSampleGamemode.sqf** - Собственно описание класса нашего режима.
- **GMSampleGamemode_roles.sqf** - Описание базовой роли для нашего режима. Сюда же мы будем вписывать свои роли, про создание которых описано [в руководстве по созданию ролей](Editor_roles.md)
- **loader.hpp** - загрузчик всех файлов режима. Если мы добавляем свои файлы, относящиеся к режиму или например хотим отсортировать роли нашего режима по разным файлам, то все эти файлы так же должны быть дозагружены через loader.hpp.


# Разработка режима

Итак, откроем в редакторе VS Code файл **GMSampleGamemode.sqf**

<img src="Data/editor_gamemode_code.png" width="100%">

В сгенерированном файле режима уже автоматически установлено его название и название нашей созданной карты. 

Строчка `#include <..\GameMode.h>` означает **подняться на директорию выше** и вставить содержимое из файла `GameMode.h` в целевой файл. Нужна она для того, чтобы нам не подключать массу различных заголовочных файлов для полной работы. Мы просто подключили GameMode.h и больше не паримся...

Дальше написан `editor_attribute("CodeOnyGamemode")`. Не придавайте этому особого значения. Это просто атрибут для режима редактора, который помечат класс как режим, разрабатываемый через код.

На следующей строке идёт определение (*декларация*) класса нашего игрового режима. Обратите внимание, что класс наследует логику от `GMBase`. GMBase - это базовый класс игрового режима, который поддерживает основную логику и предоставляет полезные функции. Вы можете ознакомиться с содержимым базового режима GMBase для ознакомления со всеми возможными полями и методами. Там они так же хорошо задокументированы как и в сгенерированном режиме, но в более системном формате.

Любой режим должен иметь название, описание и наверное какую-то продолжительность игры. Укажем в полях (переменных класса) имя режима (**name**), описание (**desc**), доступное при выборе администратором или через голосование а также расширенное описание (**descExtended**), показываемое в конце раунда. 

Продолжительность игры задается через поле продолжительности (**duration**), указываемое в секундах. Чтобы конвертировать секунды в минуты, нужно умножить количество минут на 60. Например, режим, длительностью 45 минут можно было бы определить таким образом: `var(duration,60*45);`.
Однако для дополнительного удобства в заголовочном файле `engine.hpp`, который кстати уже подключен в `GameMode.h` существет несколько полезных макросов для работы со временем:
- t_asMin(s) - Преобразуер значение s минут в секунды. 
```sqf
t_asMin(45); // 2700 секунд
```
- t_asHrs(s) - Преобразует значение s часов в секунды.
```sqf
t_asHrs(2); // 7200 секунд
```

<img src="Data/editor_gamemode_naming.png" width="100%">

Ниже идёт константная функция `getMapName`. Она просто возвращает название файла карты. Кстати если преобразовать константную функцию в обычную, то можно настроить логику выбора разных карт одним режимом.

Далее раздел настроек случайности. Раздел подробно задокументирован и тут нужно лишь подобрать оптимальные значения.

В разделе настроек для лобби (`getLobbySoundName, getLobbyBackground`) можно указать задний фон лобби и музыкальную тему. Аудио лежит в папке `Resources\music`. Композиция должна быть в `.ogg` формате. Изображения для лобби лежат в папке `Resources\ui\lobby` и сохранены в формате `.paa`.

# Добавление ролей в режим

Чуть ниже после настроек заднего фона лобби и музыки присутствуют 2 метода со списоком ролей для лобби и во время игры. Более детально добавление ролей будет рассмотрено в [руководстве по созданию ролей](Editor_roles.md)

## getLobbyRoles
- Данный метод должен возвращать массив строк. В строках должны быть указаны имена классов ролей, которые будут доступны до старта раунда. 
## getLateRoles
- Данный метод должен возвращать массив строк, аналогично getLobbyRoles. Этот список становится доступен сразу после старта раунда. Так же роли, которые настроены как доступные после старта раунда также будут автоматически переноситься в этот список. Это значит, что вам не требуется дублировать роли, доступные во время всего цикла игры в оба массива.

# Дополнительные настройки режима
Раздел дополнительных настроек позволяет включить режим в систему голосования, разрешить систему аспектов раунда и настроить работу случайных событий (*Влияний Реликты*), происходящих во время процесса игры.

# Основные события режима

Перед началом раунда мы должны убедиться что все условия для его старта соблюдены. Чаще всего это выражается в проверки занятости определенных ролей, реже для проверки количества человек на сервере. Однако вы можете добавить любую пользовательскую логику условия для старта режима.

## Событие возможности старта режима

Для проверки возможности запуска режима существует метод **conditionToStart**, который возвращает bool и выполняющийся когда таймер лобби стал равен 0. В случае **true** режим будет запущен, а в случае **false** таймер запустится заново. 

Например напишем простую логику, что за все доступные лобби роли зашёл хотя бы один человек. Для получения количества кандидатов, занявших определенную роль в базовом режиме `GMBase` определён метод **getCandidatesCount**:

```sqf
func(conditionToStart)
{
	objParams();

	// Получаем количество ролей, доступных в лобби
	// count - встроенная унарная функция
	private _countLobbyRoles = count callSelf(getLobbyRoles);
	// Счетчик ролей, которые кто-то занял
	private _countNonEmptyRoles = 0;

	// Итерируем (перебираем) каждый элемент массива, возвращаемого getLobbyRoles
	{
		// на каждой итерации специальная переменная _x принимает значение текущего элемента массива

		// вызываем метод getCandidatesCount, передав аргументом _x (класснейм роли) 
		// и сравниваем больше нуля количество кандидатов на роль
		if (callSelfParams(getCandidatesCount,_x) > 0) then {
			// Увеличиваем счетчик непустых ролей на 1
			_countNonEmptyRoles = _countNonEmptyRoles + 1;
		};
	} foreach callSelf(getLobbyRoles);

	// Последнее выражение является "возвращаемым значением"

	// Если счетчик непустых ролей равен количеству всех ролей
	_countNonEmptyRoles == _countLobbyRoles
};
```

Но игрокам хотелось бы знать причину чего действительно не хватило для запуска режима. На этот случай существует метод **onFailReasonToStart**, который должен возвращать строку. Данная строка будет выведена в лобби в момент когда таймер сбросился.

```sqf
func(onFailReasonToStart)
{
	objParams();
	"Не все роли заняты";
};
```

Получилось достаточно обобщенно. Хотелось бы больше информативности. Давайте немного изменим метод, и выведем какие именно роли не были заняты:

```sqf
func(onFailReasonToStart)
{
	objParams();
	
	// Создаем пустой массив, в который будет добавлять не занятые роли
	private _needRoles = [];
	
	{
		if (callSelfParams(getCandidatesCount,_x) == 0) then {
			_needRoles pushBack _x; // pushBack - бинарная встроенная функция
			// Означает: поместить элемент _x в конец массива _needRoles
		};
	} foreach callSelf(getLobbyRoles);

	"Не все роли заняты. Нужно занять: " + (_needRoles joinString ",");
};
```

Отлично. Теперь **onFailReasonToStart** будет информировать какие именно роли не были заняты. Однако они будут выводиться как имена классов. Сделаем небольшой хак и ещё немного улучшим данный метод, вычислив из имени типа значение имени роли.

```sqf
func(onFailReasonToStart)
{
	objParams();

	private _needRoles = [];

	{
		if (callSelfParams(getCandidatesCount,_x) == 0) then {
			// Проверим действительно ли существует класс с таким именем
			
			// isImplementClass() - макрос, который в качестве аргумента
			// принимает строку и проверяет есть ли класс, определенный 
			// с таким названием. Например, isImplementClass("GMSampleGamemode") вернет true

			if isImplementClass(_x) then {

				// getFieldBaseValue() - макрос, который принимает в качестве
				// аргументов строку с именем класса и строку с именем поля (переменной)
				// и возвращает начальное значение, определенное в классе
				private _roleName = getFieldBaseValue(_x,"name");
				_needRoles pushBack _roleName;
			};
		};
	} foreach callSelf(getLobbyRoles);

	"Не все роли заняты. Нужно занять: " + (_needRoles joinString ",");
};
```

> **Обратите внимание!**
>> Макросы для работы с типами `isImplementClass()` и `getFieldBaseValue()` определены в основном заголовочном файле `oop.hpp`, который так же содержится внутри `GameMode.h`

# Ключевые события и цикл раунда

Ещё ниже мы можем наблюдать группу методов, которые вызываются в основных точках режима: старте, конце и в каждой секунде.

## Событие preSetup
Данный метод вызывается когда наш режим GMSampleGamemode был установлен администратором либо выбран системой как случайный. Иными словами - метод является стартовой точкой цикла симуляции режима. 
В момент вызова метода **preSetup** карта уже создана, поэтому мы можем предварительно подготовить её перед началом раунда: создать или удалить дополнительные объекты или просчитать сложные вычисления (например, сгенерировать пещеры), которые могут понадобится при старте или во время раунда. 

Для примера работы давайте попробуем заменить все наши блоки земли на каменные блоки.

Порядок действий в коде будет таков:
1. Собираем все блоки земли (с именем класса BlockDirt) на карте с помощью функции `getAllObjectsInWorldTypeOf`
2. Получаем позицию и направления каждого из блока
3. Создаем декорацию блока камня (тип BlockStone) на позиции блока земли
4. Удаляем блок земли.

```sqf
	// Вызывается когда режим GMSampleGamemode выбран (до старта раунда с загруженной картой)
	func(preSetup)
	{
		objParams();

		// Получаем список всех блоков земли на карте
		// Второй аргумент означает нужно ли возвращать объекты, унаследованные от BlockDirt
		private _listBlocks = ["BlockDirt",false] call getAllObjectsInWorldTypeOf;
		{
			// Получаем координаты блока
			private _blockPos = callFunc(_x,getPos);
			private _blockDir = callFunc(_x,getDir);
			
			// Создаем декорацию BlockStone
			// 4 аргумент принимает false для того, чтобы объект оставался висеть на созданной позиции
			// Иными словами, аргумент указывает, что нужно отключить "эмуляцию падения" объекта
			["BlockStone",_blockPos,_blockDir,false] call createDecoration;
			
			// Удаляем блок земли
			delete(_x);
		} foreach _listBlocks;
	};
```

Теперь неплохо было бы проверить что у нас получилось. Для этого давайте поставим внутри нашей сцены немного освещения и затем нажмем ПКМ по поверхности земли и в контекстном меню выберем `Запустить симуляцию отсюда`

<img src="Data/editor_gamemode_presetupcheck.png" width="100%">

И в игре мы видим, что наши блоки земли стали... блоками камня!

<img src="Data/editor_gamemode_presetupview.png" width="100%">

Это был лишь небольшой пример использования события preSetup. Конечно вы можете придумать массу способов и вариантов использования данного события. Всё зависит лишь от вашей фантазии.

## Событие postSetup
Данный метод вызывается сразу после старта раунда, когда все игроки уже загрузились в свои роли. **postSetup** полезен, если мы хотим произвести некоторую режимную логику, требующую информации о персонажах, которые есть в игре со старта раунда. Например: обработать антагонистов - выдать им задачи и информационные сообщения о том, что именно им нужно сделать. И пока мы ещё не добрались до части кода, отвечающего за обработку и выбор антагонистов, предлагаем сделать голод всем персонажам, зашедшим в раунд с начала. А чтобы они не умерли с голоду - дадим им в руки немного еды.

Здесь порядок действия имеет много схожего с кодом, который мы писали для события preSetup:
1. Собираем всех сущностей (персонажей) на карте с помощью функции getAllMobsInWorld.
2. Устанавливаем каждому персонажу голод на некоторое значение.
3. Выдаем персонажу предмет в активную руку с помощью createItemInInventory

```sqf
// Вызывается после начала раунда когда все клиенты зашли в игру
func(postSetup)
{
	objParams();

	// Получаем список всех персонажей на карте
	// Второй аргумент означает нужно ли возвращать объекты, унаследованные от Mob
	// Так как женские персонажи унаследованы от Mob, то устанавливаем агрумент как true
	private _allMobs = ["Mob",true] call getAllMobsInWorld;

	{
		// Устанавливаем голод на низкое значение
		callFuncParams(_x,setHunger,20);

		// Выдаем персонажу еду в активную руку
		["Egg",_x] call createItemInInventory;
	} foreach _allMobs;
};
```

Когда вы отредактировали код клиента или сервера, нажмите `Esc` и нажмите розовую кнопку `Compile and run`. После этого все классы и функции будут перекомпилированы и цикл симуляции запустится сначала. 

Вышло достаточно примитивно, но зато наш персонаж не умрет с голоду... в ближайшее время.

## Обработчик checkFinish
Каждый раунд должен в конце концов быть завершен. И на наши плечи ложится ответственность за то, чтобы он заканчивался различными способами. Для этого нам понадобится метод **checkFinish**. Он вызывается раз в секунду с начала раунда и до его конца. Как правило checkFinish обрабатывает логику, проинициализированную в postSetup. 

В нашем сгенерированном режиме checkFinish уже обрабатывает длительность раунда. Давайте попробуем добавить условие, что раунд завершится если вся еда, выданная персонажам в postSetup была съедена. Для этого придется немного модифицировать метод postSetup, занеся каждое созданное яйцо в массив, который в checkFinish будет проверяться раз в секунду.

```sqf
var(allEggs,[]); //сюда будут записываться объекты созданной нами еды

func(postSetup)
{
	objParams();

	private _allMobs = ["Mob",true] call getAllMobsInWorld;

	{
		// Устанавливаем голод на низкое значение
		callFuncParams(_x,setHunger,20);

		// Выдаем персонажу еду в активную руку
		private _newEgg = ["Egg",_x] call createItemInInventory;
		
		// Добавляем в массив allEggs созданное яйцо
		getSelf(allEggs) pushBack _newEgg;
	} foreach _allMobs;
};
```

Теперь изменим checkFinish:

```sqf
// Проверка режима. Выполняется каждую секунду
// Возвращаемое значение должно быть числом
// Любое число, не равное 0 означает конец режима
func(checkFinish)
{
	objParams();

	// Обработка конца режима по времени
	if (gm_roundDuration >= getSelf(duration)) exitWith {1};
	
	// Добавьте тут пользовательскую логику конца режима.

	// Получаем количество яиц созданных в postSetup
	private _existsEggs = count getSelf(allEggs);
	{
		// Когда яйца съедены они удаляются и все ссылки на них принимают nullPtr значение
		// Таким образом если яйца не существует - уменьшаем счетчик существующих яиц
		if isNullReference(_x) then {
			_existsEggs = _existsEggs - 1;
		};
	} foreach getSelf(allEggs);

	// Если счетчик существующих яиц равен 0 завершаем раунд с кодом 2
	if (_existsEggs <= 0) exitwith {2};
	
	0
};
```
Но вот режим завершается и мы видим следующее:

<img src="Data/editor_gamemode_checkfinishrez.png" width="100%">

**Неизвестная причина** - это необработанное условие конца раунда. Если бы в раунде закончилось время, то нам показало совершенно другую причину конца раунда. А как определить свою причину завершения смотрите ниже

### Вывод результата конца раунда
Для вывода результата конца раунда используется метод **getResultTextOnFinish**. Принцип работы аналогичен методу `onFailReasonToStart`, только вызывается он когда режим завершён. Для получения результата конца раунда используйте `getSelf(finishResult)`

```sqf
func(getResultTextOnFinish)
{
	objParams();

	if (getSelf(finishResult) == 1) exitWith {
		"Время режима закончилось."
	};
	// Добавляем свою причину когда съедены все яйца
	if (getSelf(finishResult) == 2) exitWith {
		"Все яйца съедены."
	};
	
	
	"Неизвестная причина."
};
```

<img src="Data/editor_gamemode_checkfinishokrez.png" width="100%">

Таким образом мы можем создавать и комбинировать множество различных вариаций конца режима. Тут опять же всё упирается в вашу фантазию.

## Событие onFinish

В методе **onFinish** обычно выводится результат конца раунда в более подробной форме. Обратите внимание, что изначально onFinish вызывает базовый метод с помощью ооп-макроса `super()`. Иными словами - super вызывает функционал метода onFinish, определенного в GMBase. Так нам не требуется каждый раз дублировать какой-либо код. В базовом методе onFinish выводится коротка сводка конца раунда, включающая название, описание, результат из getResultTextOnFinish, статистические данные как например количество выбитых зубов.

# Работа с антагонистами