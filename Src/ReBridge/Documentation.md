# ReEngine

ReEngine - это библиотека, позволяющая реализовать практически любой функционал с помощью языка C#. Расширение реализует привязку и создание динамических сборок прямо во время выполнения платформы Arma 3.

# How it works
Библиотека ReEngine разделена на 2 основных компонента: **ReScript** и **Bridge**. 

## ReScript 
ReScript реализует функционал решения ([вот тут можно подробнее ознакомиться](https://github.com/oleg-shilo/cs-script.core)) для компиляции обычного .cs кода в сборки как в виде dll файлов, так и напрямую в память процесса. Дело в том, что в .NET нельзя выгружать уже загруженные сборки - они могут быть выгружены после закрытия приложения. Можно использовать способ с созданием отдельного AppDomain, но у этого варианта тоже есть свои проблемы. Именно поэтому на данный момент CS-Script является самым оптимальным решением для реализации расширений в проекте.
Внутри ReEngine процессом компиляции и вызова скриптов управляет статический класс (``ReScriptBuilder``). Он реализует все высокоуровневые методы: собрать проект из скриптов ``Build``, создать объект скрипта (``InitScript``), вызвать команду в скрипте (``Command``) или очистить память от всех созданных скриптов (``UnloadScriptEngine``). Детально расписывать работу и предназначение каждого из методов данного класса нет смысла - каждый из них задокументирован настолько, насколько это возможно. *Так же через данный компонет можно создавать абстрагированные методы и делегаты, но на данный момент этот функционал не используется.*
### Получение дополнительных аргументов в скриптах
Внутри скриптов, унаследованных от ``IScript`` как вы уже знаете есть обработчик команд ``Command(string command, StringBuilder output)``. В случае если мы передали больше аргументов в этот обработчик с помощью платформы, получить их можно с помощью метода 
> ```cs 
>ReScriptBuilder.GetScriptArgument(int index)
>```
Данный метод возвращает аргумент, присланный из движка платформы в виде строки. Обратите внимание, что если индекс выходит за диапазон массива аргументов исключение не будет выброшено, однако метод вернёт значение **null**.

В свою очередь узнать количество аргументов можно с помощью:
>```cs 
>ReScriptBuilder.GetScriptArgumentsCount()
>```
### Методы расширения
Все методы расширения для обработки и преобразовывания строк (и немножко чисел) задокументированы и определены по пути проекта: 
> ReEngine\ReEngine\ClassExtensions.cs

## Bridge
Bridge это двухсторонний компонет для взаимодействия ReEngine и RVEngine (взаимодействие движка платформы с нашим решением). Одним словом - это мост, соединяющий 2 движка и синхронизирующий контексты выполнения в нужные моменты.
Bridge реализован для решения следующих задач:
1. Обработка команд, отправленных из армы а так же синхронизация состояний объектов. Он позволяет удалённо вызвать низкоуровневые методы с использованием ``System.Reflection`` или установить свойства для полей объектов.
2. Отправка обратных вызовов (коллбэков) из ReEngine в платформу. *К примеру, когда какой-то персонаж захочет пить и ReEngine захочет отправить клиенту сообщение о необходимости попить мы будем использовать коллбэки.*

Со сотороны армы в свою очередь реализуется интерфейс Bridge для обработки обратных вызовов и инициализации компонетов движка когда ему нужно. Весь процесс взаимодействия выглядит следующим образом:
> ***Arma***
>> Отправляет команду в библиотеку движка
             |
             V
> ***ReEngine***
>> Обрабатывает команду. Возвращает результат выполнения команды
>> Команда обрабатывается в своём потоке
> 
> *(Проходит время...)*
>> Срабатывает логика обратного вызова (например синхронизация данных для клиента) 
             |
             V
> ***Arma***
>> Обрабатываем обатный вызов
Из схемы выше наглядно показана работа связи двух движков с помощью Bridge: всё начинается с армы - она отправляет команды в движок, движок обрабатывает команды и внутреннее состояние своих созданных объектов. При необходимости движок отправляет коллбэки обратно в арму. 
Система закольцована и два движка связаны. ReEngine никогда не начнёт работу без команд армы а арма никак не будет реагировать если движок не скажет ей что-то. 

# Ограничения и особенности ReScript

## Пространства имён
Ввиду некоторых особенностей используемого evaluator-а пакета cs-script, коим является виртуальный компилятор Roslyn, не позволяется определять классы скриптов и объектов в пространствах имён. Несомненно есть несколько способов как обойти эту проблему, но пока имеем то, что имеем. Так же есть определённая вероятность коллизии пространств имён при сборке в один цельный файл. Дело в том, что для фунционирования наследования скриптов друг с другом приходится *сшивать* все скрипты проекта в один большой файл. Очевидно, что в определённых обстоятельствах могут возникнуть ошибки с неоднозначностью имён классов. Именно поэтому рекомендуется уделять особое внимание именам классов.

## Скрипты
Каждый игровой скрипт должен быть унаследован от интерфейса **ReEngine.IScript** и должен реализовывать методы инициализации скрипта, уничтожения и обработки команды. Объект каждого скрипта создаётся единожды. При попытке создать ранее созданный скрипт возникнет исключение.
